/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f1xx.h>
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void ClockInit();
void GPIO_Config (void);
void TIM1Init();
void Interrupt_Config (void);

uint8_t BTN1_pushed = 0;

int main(void)
{
	ClockInit();
	GPIO_Config();
	TIM1Init();
	Interrupt_Config ();

    /* Loop forever */
	for(;;);
}

void ClockInit(){
	// Bit 4 PRFTBE: Prefetch buffer enable
	FLASH->ACR |= (1 << 4); // Prefetch is enabled

	//
	// HSE Configuration
	// Bit 16 HSEON: HSE clock enable
	RCC->CR |= (1 << 16); // HSE oscillator ON

	/* Wait till HSE is ready */
	// Bit 17 HSERDY: External high-speed clock ready flag
	while(!(RCC->CR & (1 << 17)));

	//
	// PLL Configuration
	/* Disable the main PLL. */
	// Bit 24 PLLON: PLL enable
	RCC->CR &= ~(1 << 24); // PLL OFF

	/* Wait till PLL is disabled */
	// Bit 25 PLLRDY: PLL clock ready flag
	while(RCC->CR & (1 << 25));

	/* Set PREDIV1 Value */
	// Bit 17 PLLXTPRE: HSE divider for PLL entry
	RCC->CFGR &= ~(1 << 17); // HSE clock not divided

	/* Configure the main PLL clock source and multiplication factors. */
	// Bit 16 PLLSRC: PLL entry clock source
	RCC->CFGR |= (1 << 16); // HSE oscillator clock selected as PLL input clock
	// Bits 21:18 PLLMUL: PLL multiplication factor
	RCC->CFGR &= ~(0b1111 << 18);
	RCC->CFGR |= (0b111 << 18); // PLL input clock x 9

	/* Enable the main PLL. */
	// Bit 24 PLLON: PLL enable
	RCC->CR |= (1 << 24); // PLL ON

	/* Wait till PLL is ready */
	// Bit 25 PLLRDY: PLL clock ready flag
	while(!(RCC->CR & (1 << 25)));

	// Bits 2:0 LATENCY: Latency
	FLASH->ACR &= (0b111 << 0);
	FLASH->ACR |= (0b10 << 0); // Two wait states, if 48 MHz < SYSCLK <= 72 MHz

	// HCLK Configuration
	/* Set the highest APBx dividers in order to ensure that we do not go through
	      5     a non-spec phase whatever we decrease or increase HCLK. */
	// Bits 10:8 PPRE1: APB low-speed prescaler (APB1)
	RCC->CFGR |= (0b111 << 8); // HCLK divided by 16
	// Bits 13:11 PPRE2: APB high-speed prescaler (APB2)
	RCC->CFGR |= (0b111 << 11); // HCLK divided by 16

	/* Set the new HCLK clock divider */
	// Bits 7:4 HPRE: AHB prescaler
	RCC->CFGR &= ~(0b1111 << 4); // SYSCLK not divided

	//
	// SYSCLK Configuration
	/* PLL is selected as System Clock Source */
	// Bit 25 PLLRDY: PLL clock ready flag
	/* Check the PLL ready flag */
	while(!(RCC->CR & (1 << 25)));

	// Bits 1:0 SW: System clock switch
	RCC->CFGR &= ~(1 << 0); // PLL selected as system clock
	RCC->CFGR |= (1 << 1);

	while( ( ( RCC->CFGR & (0b11 << 2) ) >> 2 ) != (0b10) ); // Bits 3:2 SWS: System clock switch status

	//
	// PCLK1 Configuration
	// Bits 10:8 PPRE1: APB low-speed prescaler (APB1)
	RCC->CFGR &= ~(0b111 << 8);
	RCC->CFGR |= (0b100 << 8); // HCLK divided by 2

	// PCLK2 Configuration
	// Bits 13:11 PPRE2: APB high-speed prescaler (APB2)
	RCC->CFGR &= ~(0b111 << 11); // HCLK not divided
}

void GPIO_Config (void)
{
   // Set IOPB EN
   RCC->APB2ENR |= (1 << 3); // Enable GPIOB clock

   GPIOB->CRH |= (1 << 24) | (1 << 28);
   GPIOB->CRH &= ~((1 << 25) | (1 << 29));

   GPIOB->CRH &= ~((0b11 << 26) | (0b11 << 30));
}

void Interrupt_Config (void)
{
	// Bit 0:0 AFIOEN: Alternate function IO clock enable
	RCC->APB2ENR |= (1 << 0); // 1: Alternate Function IO clock enabled

	// Bits 7:4 EXTI1[3:0]: EXTI 1
	AFIO->EXTICR[0] &= 	~(0xF << 4);
	AFIO->EXTICR[0] |= 	(1 << 4); // 0001: PB1 pin

	// Bits 1:1 MRx: Interrupt Mask on line 1
	EXTI->IMR |= (1 << 1); // Interrupt request from Line 1 is not masked

	//
	// Bits 1:1 TRx: Rising trigger event configuration bit of line 1
	EXTI->RTSR |= (1 << 1); // Rising trigger enabled (for Event and Interrupt) for input line

	// Bits 1:1 TRx: Falling trigger event configuration bit of line 1
	EXTI->FTSR |= (1 << 1); // Falling trigger enabled (for Event and Interrupt) for input line.

	//
	NVIC_SetPriority(EXTI1_IRQn, 1);
	NVIC_EnableIRQ(EXTI1_IRQn);
}

void EXTI1_IRQHandler(void)
{

	// PRx: Pending bit
	if(EXTI->PR & (1 << 1)) // 1: selected trigger request occurred
	{
		EXTI->PR |= (1 << 1); // "This bit is cleared by writing a ‘1’ into the bit. "
	}

	BTN1_pushed ^= 1;

	if(BTN1_pushed)
	{
		// Bit 0 CEN: Counter enable
		TIM1->CR1 |= (1 << 0); // Counter enabled

		GPIOB->ODR |= (1 << 14); // Turn on LED2
	}
	else
	{
		// Bit 0 CEN: Counter enable
		TIM1->CR1 &= ~(1 << 0); // Counter disabled

		// Bits 15:0 CNT[15:0]: Counter value
		TIM1->CNT = 0;

		GPIOB->BSRR |= (0b11 << 30); // Off 2 LEDs
	}

}

void TIM1Init()
{
	// Bit 11 TIM1EN: TIM1 timer clock enable
	RCC->APB2ENR |= (1 << 11); // TIM1 timer clock enabled

	// Bits 15:0 PSC[15:0]: Prescaler value
	TIM1->PSC = 7200 - 1;

	// Bit 7 ARPE: Auto-reload preload enable
	TIM1->CR1 |= (1 << 7); // TIMx_ARR register is buffered

	// Bits 15:0 ARR[15:0]: Auto-reload value
	TIM1->ARR = 20000;

	// Clear UIF flag
	TIM1->SR = 0;

	// Bit 0 UIE: Update interrupt enable
	TIM1->DIER |= (1 << 0); // Update interrupt enabled

	NVIC_EnableIRQ(TIM1_UP_IRQn);
	NVIC_SetPriority(TIM1_UP_IRQn, 2);
}

void TIM1_UP_IRQHandler()
{
	// Clear UIF flag
	TIM1->SR = 0;

	GPIOB->ODR |= (1 << 15); // Turn on LED3
}
